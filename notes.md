# Notes
Here is a link to the <a href="README.md">README.md</a>.

These are notes that can be used on midterms and the final exam. This file can be modified through the entire class. Other .md files can be added and linked here to help things be more organized.

## Git and GitHub
**Git provides two valuable functions:**
- First, it allows you to track versions of files in a directory. 
- Second, it allows you to clone all of those versions to a different location, usually to a different computer.

**Helful commands:**
- `echo` - output the parameters of the command
- `cd` - change directory
- `mkdir` - make directory
- `rmdir` - remove directory
- `rm` - remove file(s)
- `mv` - move file(s)
- `cp` - copy files
- `ls` - list files
- `curl` - command line client URL browser
- `grep` - regular expression search
- `find` - find files
- `top` - view running processes
- `df` - view disk statistics
- `cat` - output file
- `less` - interactive file output
- `wc` - count words
- `ps` - view processes
- `kill` - kill a process
- `sudo` - execute as a admin
- `ssh` - remote shell
- `scp` - securely copy files to a remote computer
- `history` - show history of commands
- `ping` - test connection
- `tracert` - trace network
- `dig` - DNS info
- `man` - look in the manual to find out how a command works
```
git clone {repository URL}
git commit -am "message"
git pull
git push
git add
git init
git diff {HEAD HEAD~1}
```

**Commit SHA:**
- Every commit has a unique identifier that is generated by hashing the file along with the timestamp using the SHA hashing algorithm. You can always refer to a specific commit in your version history by using its SHA.

**Branches:**
- Allows you to work on variations of the code while still allowing progress on the main branch.

***For the future: ask if images and gifs can be added to the notes.md or if it is text only.***

**Creating files and adding them to the repository after you've cloned from GitHub:**
```
git add file.filetype
git commit -am "really great commit message here"
git push
```
**Basic development process:**
1. Pull the repository's latest changes from GitHub (git pull)
1. Make edits
1. Commit the changes (git commit)
1. Push the changes to GitHub (git push)

*Remember to commit often and with good comments!*

**Merges:**
```
git fetch
git status
Your branch and 'origin/main' have diverged,
and have 1 and 1 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)
```
This shows there is a conflict that needs to be merged since Git doesn't know which commit to keep.
```
git pull
Auto-merging test.md
CONFLICT (content): Merge conflict in test.md
Automatic merge failed; fix conflicts and then commit the result.
```
Once you find the conflict, pick which one to keep and modify teh file to keep the wanted changes. Then commit and push again.
```
git commit -am "awsome comment about the merge"
git push
```

**Forks:**
- A GitHub fork provides the ability to create a copy of a GitHub repository.
- Usually you fork a repo to get a copy of an open source code base that you want to experiment with, or contribute to.
- A fork is similar to cloning a repository to your development environment, but it clones to GitHub instead.
- Pull a fork down to your development environment to work on it.
- A fork also allows you to create a pull request in order to push suggested changes to the original repository.

## Deployment
Try to mostly use automated or scripted deployments since it will reduce chances of accidentally delete a file, or misconfiguring something with an stray keystroke. An automated deployment process is reproducible and encourages you to iterate quickly because it is so much easier to deploy your code. You can add a small feature, deploy it out to production, and get feedback within minutes from your users.

Our deployment scripts change with each new technology that we have to deploy. Initially, they just copy up a directory of HTML files, but soon they include the ability to modify the configuration of your web server, run transpiler tools, and bundle your code into a deployable package.

You run a deployment script from a console window in your development environment with a command like the following:
```
./deployService.sh -k ~/prod.pem -h yourdomain.click -s simon
```
The `-k` parameter provides the credential file necessary to access your production environment. The `-h` parameter is the domain name of your production environment. The `-s` parameter represents the name of the application you are deploying (either simon or startup).

**How the script works:**
The first part of the script simply parses the command line parameters so that we can pass in the production environment's security key (or PEM key), the hostname of your domain, and the name of the service you are deploying.
```
while getopts k:h:s: flag
do
    case "${flag}" in
        k) key=${OPTARG};;
        h) hostname=${OPTARG};;
        s) service=${OPTARG};;
    esac
done

if [[ -z "$key" || -z "$hostname" || -z "$service" ]]; then
    printf "\nMissing required parameter.\n"
    printf "  syntax: deployService.sh -k <pem key file> -h <hostname> -s <service>\n\n"
    exit 1
fi

printf "\n----> Deploying $service to $hostname with $key\n"
```
Next the script copies all of the applicable source files into a distribution directory (dist) in preparation for copying that directory to your production server.
```
# Step 1
printf "\n----> Build the distribution package\n"
rm -rf dist
mkdir dist
cp -r application dist
cp *.js dist
cp package* dist
```
The target directory on your production environment is deleted so that the new one can replace it. This is done by executing commands remotely using the secure shell program (`ssh`).
```
# Step 2
printf "\n----> Clearing out previous distribution on the target\n"
ssh -i $key ubuntu@$hostname << ENDSSH
rm -rf services/${service}
mkdir -p services/${service}
ENDSSH
```
The distribution directory is then copied to the production environment using the secure copy program (`scp`).
```
# Step 3
printf "\n----> Copy the distribution package to the target\n"
scp -r -i $key dist/* ubuntu@$hostname:services/$service
```
We then use `ssh` again to execute some commands on the production environment. This installs the node packages with `npm install` and restarts the service daemon (`PM2`) that runs our web application in the production environment.
```
# Step 4
printf "\n----> Deploy the service on the target\n"
ssh -i $key ubuntu@$hostname << ENDSSH
cd services/${service}
npm install
pm2 restart ${service}
ENDSSH
```
Finally we clean up our development environment by deleting the distribution package.
```
# Step 5
printf "\n----> Removing local copy of the distribution package\n"
rm -rf dist
```